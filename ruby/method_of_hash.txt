                                                     
3.0.1 :001 > h={:f =>1, :b =>2, :c=>3}                    #old method
 => {:f=>1, :b=>2, :c=>3} 
3.0.1 :002 > h[:f]
 => 1

3.0.1 :019 > h={name: 'vicky',c: 'btech', r:168}           #new method
 => {:name=>"vicky", :c=>"btech", :r=>168} 
3.0.1 :020 > 
..................................................................using function call...........................

3.0.1 :001 > def some_method(hash)
3.0.1 :002 >   p hash
3.0.1 :003 > end
 => :some_method 
3.0.1 :004 > some_method({a: 0,b: 1,c:3})
{:a=>0, :b=>1, :c=>3}
 => {:a=>0, :b=>1, :c=>3} 
3.0.1 :005 > 

3.0.1 :012 > class Sample 
3.0.1 :013 >   attr_accessor :name, :lang
3.0.1 :014 >   def initialize(hash)
3.0.1 :015 >     self.name=hash[:name]
3.0.1 :016 >     self.lang=hash[:lang]
3.0.1 :017 >   end
3.0.1 :018 > end
 => :initialize 
3.0.1 :019 > 
3.0.1 :019 > h=Sample.new(name: 'vicky',lang:'ruby')
 => #<Sample:0x00005645bedbb988 @lang="ruby", @name="vicky"> 
3.0.1 :020 > h
 => #<Sample:0x00005645bedbb988 @lang="ruby", @name="vicky"> 
3.0.1 :021 > 
.......................................................................................................................
3.0.1 :021 > h=Hash.new                                       # creating hash...
 => {} 
3.0.1 :022 > h.class
 => Hash 
3.0.1 :023 > h=Hash[]
 => {} 
3.0.1 :024 > h=Hash[a:1,b:2,c:3]
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :025 > h={}
 => {} 

3.0.1 :026 > h={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :028 > h[:a]
 => 1 

......................................................create and access hash key .......................................

.0.1 :001 > h={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :002 > h['a']
 => nil 
3.0.1 :003 > h[:'a']
 => 1 
3.0.1 :004 > h[:a]
 => 1 
3.0.1 :005 > my_h={'a': 1,'b': 2}
 => {:a=>1, :b=>2} 
3.0.1 :006 > my_h['a']
 => nil 
3.0.1 :007 > hash={'a'=> 1,'b'=>2}
 => {"a"=>1, "b"=>2} 
3.0.1 :008 > hash['a']
 => 1 
3.0.1 :009 > hash[:'a']
 => nil 
3.0.1 :010 > 

......................................................................#adding key value to hash..............

3.0.1 :029 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :030 > h[:d]=4
 => 4 
3.0.1 :031 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :032 > h[:e]=5
 => 5 
3.0.1 :033 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>5} 

3.0.1 :054 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :055 > h.store(:d,4)                  # h.store(:key,val) used to add 
 => 4 
3.0.1 :056 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
 
...................................................delete h key value from hash.....................

3.0.1 :036 > h.delete(:e)
 => 5 
3.0.1 :037 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :038 > 
.................................................update value of some key.....

3.0.1 :037 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :038 > h[:d]=10
 => 10 
3.0.1 :039 > h
 => {:a=>1, :b=>2, :c=>3, :d=>10} 
.................................................using key as an array in hash.............

3.0.1 :041 > a1=[:a,:b]
 => [:a, :b] 
3.0.1 :042 > a2=[:c,:d]
 => [:c, :d] 

3.0.1 :043 > h={a1=>1,a2=>2}
 => {[:a, :b]=>1, [:c, :d]=>2} 

3.0.1 :044 > h.include?(a1)
 => true 
3.0.1 :045 > h[a1]
 => 1 
3.0.1 :046 > h[a2]
 => 2 
.................................................updating key is going to chnage the hash value

3.0.1 :049 > a1.hash
 => -3904225525138141559 
3.0.1 :050 > a1
 => [:a, :b] 
3.0.1 :052 > a1[0]=:e
 => :e 
3.0.1 :055 > a1.hash
 => -908128488615875714 
3.0.1 :056 > 
3.0.1 :054 > h
 => {[:e, :b]=>1, [:c, :d]=>2} 
.................................................. updating a1[0],damaged the hash index..........
3.0.1 :056 > h.include?(a1)
 => false 

3.0.1 :060 > h[a1]
 => nil 

....................................................to fix above use rehash method, index using below..............
3.0.1 :061 > h.rehash
 => {[:e, :b]=>1, [:c, :d]=>2} 
3.0.1 :062 > h.include?(a1)
 => true 
3.0.1 :063 > h[a1]
 => 1 
3.0.1 :064 > 
.............................................  ... set default value of hash.....if not present..................

3.0.1 :009 > count={a:1}
 => {:a=>1} 
3.0.1 :010 > count.default
 => nil 
3.0.1 :011 > count[:a]
 => 1 
3.0.1 :012 > count[:b]
 => nil 
3.0.1 :013 > count.default=0
 => 0 
3.0.1 :014 > count[:b]
 => 0 

3.0.1 :016 > count.values_at(:a,:b,:c)                 # h.values_at(:key,....)
 => [1, 0, 0] 
3.0.1 :017 > 

....................................................

3.0.1 :038 > h=Hash[[:a,1],[:b,2]]
 => {[:a, 1]=>[:b, 2]} 

3.0.1 :039 > h
 => {[:a, 1]=>[:b, 2]} 

3.0.1 :040 > h=Hash[ [ [:a, 1], [:b, 2] ] ]              #Hash[ [ [:key,val],[:k,v] ] ]
 => {:a=>1, :b=>2} 
3.0.1 :041 > 

3.0.1 :041 > h=Hash[:a, 1, :b, 2]                        #Hash[:k,v]
 => {:a=>1, :b=>2} 
 
.................................................................................
                                                        # check proper subset and subset to eachother....
3.0.1 :042 > h
 => {:a=>1, :b=>2} 

3.0.1 :043 > h2={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :045 > h<h2                     # check proper subset h<h2
 => true 
3.0.1 :046 > h2<h
 => false 
3.0.1 :047 > h<h
 => false 
3.0.1 :048 > h<=h2                    #check subset h<=h2
 => true 
3.0.1 :049 > h2<=h
 => false 
3.0.1 :050 > h<=h
 => true 
3.0.1 :051 > 

...................................................hash.any?([:k, v]) if both match then return true................................

3.0.1 :060 > h.any?([:b,1])
 => false 
3.0.1 :061 > h.any?([:b,2])
 => true 
3.0.1 :062 > h.any? {|key, value| value <3}           # h.any? {|k, v| condition} match then return true...
 => true 
3.0.1 :063 > h.any? {|key, value| value >4}
 => false 
3.0.1 :064 > 
..............................................................# h.assoc() return an array with [k,v]...................

3.0.1 :064 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :065 > h.assoc(:a)
 => [:a, 1] 
3.0.1 :066 > 
.............................................................# h.compact return copy of hash after removing all nil val............
3.0.1 :071 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>nil, :f=>nil} 

3.0.1 :072 > h1=h.compact
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :073 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>nil, :f=>nil} 

3.0.1 :074 > h1
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :076 > h.compact!
 => {:a=>1, :b=>2, :c=>3, :d=>4}                         # return self

..............................................................# hash.fetch(:k) function .....................................

3.0.1 :010 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :011 > h.fetch
3.0.1 :011 > h.fetch(:a)
 => 1 
3.0.1 :012 > h.fetch(:d)
(irb):12:in `fetch': key not found: :d (KeyError)

3.0.1 :013 > h.fetch(:d){4}                              # to ignore the above keyerror do this.....
 => 4 
3.0.1 :014 > h
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :015 > h.fetch(:d) do |k|
3.0.1 :016 >   puts "could not found #{k}"
3.0.1 :017 > end
could not found d
 => nil 
.............................................................# h.dig(:k,:k1,...)...........................

3.0.1 :021 > my_h={a: {b: {c: 1}}}                         
 => {:a=>{:b=>{:c=>1}}} 
3.0.1 :022 > my_h[:a]
 => {:b=>{:c=>1}} 
3.0.1 :023 > my_h[:b]
 => nil 
3.0.1 :024 > my_h[:c]
 => nil 
3.0.1 :025 > my_h[:a,:b,:c]
(irb):25:in `[]': wrong number of arguments (given 3, expected 1) keyerror...


3.0.1 :026 > my_h.dig(:a)                             #h.dig function useful for nested hash.....
 => {:b=>{:c=>1}} 

3.0.1 :027 > my_h.dig(:b)
 => nil 

3.0.1 :028 > my_h.dig(:c)
 => nil 
3.0.1 :029 > my_h.dig(:a,:b,:c)
 => 1 

....................................................................................................................
                                                          # iterate through hash using each..

3.0.1 :030 > h                             
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :031 > h.each do |k, v|                         #h.each
3.0.1 :032 >   puts "#{k} = #{v}"
3.0.1 :033 > end
a = 1
b = 2
c = 3
 => {:a=>1, :b=>2, :c=>3} 
.......................................
3.0.1 :037 > h.each_key do |k|                     # h.each_key
3.0.1 :038 >   puts "#{k}"
3.0.1 :039 > end
a
b
c
 => {:a=>1, :b=>2, :c=>3}
..........................................
3.0.1 :043 > h.each_key do |k|
3.0.1 :044 >   puts h[k]
3.0.1 :045 > end
1
2
3
 => {:a=>1, :b=>2, :c=>3} 
...............................................
3.0.1 :049 > h.each_value do |v|                   # h.each_value 
3.0.1 :050 >   puts v
3.0.1 :051 > end
1
2
3
 => {:a=>1, :b=>2, :c=>3} 
.................................................................................

3.0.1 :054 > h.each_with_index do |(k, v), i |                     # h.each_with_index
3.0.1 :055 >   puts "index=#{i} | key=#{k}  | value=#{v}"
3.0.1 :056 > end
index=0 | key=a  | value=1
index=1 | key=b  | value=2
index=2 | key=c  | value=3
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :057 > 
...................................................................................

3.0.1 :052 > h.keys
 => [:a, :b, :c] 
3.0.1 :053 > h.values
 => [1, 2, 3] 

3.0.1 :057 > h.to_a
 => [[:a, 1], [:b, 2], [:c, 3]] 

