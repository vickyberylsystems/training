                                                     
3.0.1 :001 > h={:f =>1, :b =>2, :c=>3}                    #old method
 => {:f=>1, :b=>2, :c=>3} 
3.0.1 :002 > h[:f]
 => 1

3.0.1 :019 > h={name: 'vicky',c: 'btech', r:168}           #new method
 => {:name=>"vicky", :c=>"btech", :r=>168} 
3.0.1 :020 > 
..................................................................using function call...........................

3.0.1 :001 > def some_method(hash)
3.0.1 :002 >   p hash
3.0.1 :003 > end
 => :some_method 
3.0.1 :004 > some_method({a: 0,b: 1,c:3})
{:a=>0, :b=>1, :c=>3}
 => {:a=>0, :b=>1, :c=>3} 
3.0.1 :005 > 

3.0.1 :012 > class Sample 
3.0.1 :013 >   attr_accessor :name, :lang
3.0.1 :014 >   def initialize(hash)
3.0.1 :015 >     self.name=hash[:name]
3.0.1 :016 >     self.lang=hash[:lang]
3.0.1 :017 >   end
3.0.1 :018 > end
 => :initialize 
3.0.1 :019 > 
3.0.1 :019 > h=Sample.new(name: 'vicky',lang:'ruby')
 => #<Sample:0x00005645bedbb988 @lang="ruby", @name="vicky"> 
3.0.1 :020 > h
 => #<Sample:0x00005645bedbb988 @lang="ruby", @name="vicky"> 
3.0.1 :021 > 
.......................................................................................................................
3.0.1 :021 > h=Hash.new                                       # creating hash...
 => {} 
3.0.1 :022 > h.class
 => Hash 
3.0.1 :023 > h=Hash[]
 => {} 
3.0.1 :024 > h=Hash[a:1,b:2,c:3]
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :025 > h={}
 => {} 

3.0.1 :026 > h={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :028 > h[:a]
 => 1 

......................................................create and access hash key .......................................

.0.1 :001 > h={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :002 > h['a']
 => nil 
3.0.1 :003 > h[:'a']
 => 1 
3.0.1 :004 > h[:a]
 => 1 
3.0.1 :005 > my_h={'a': 1,'b': 2}
 => {:a=>1, :b=>2} 
3.0.1 :006 > my_h['a']
 => nil 
3.0.1 :007 > hash={'a'=> 1,'b'=>2}
 => {"a"=>1, "b"=>2} 
3.0.1 :008 > hash['a']
 => 1 
3.0.1 :009 > hash[:'a']
 => nil 
3.0.1 :010 > 

......................................................................#adding key value to hash..............

3.0.1 :029 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :030 > h[:d]=4
 => 4 
3.0.1 :031 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :032 > h[:e]=5
 => 5 
3.0.1 :033 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>5} 

3.0.1 :054 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :055 > h.store(:d,4)                  # h.store(:key,val) used to add 
 => 4 
3.0.1 :056 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
 
...................................................delete h key value from hash.....................

3.0.1 :036 > h.delete(:e)
 => 5 
3.0.1 :037 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :038 > 
3.0.1 :072 > h.delete(:e)
 => nil 
3.0.1 :073 > h.delete(:e){|k| "key #{k} not found"}
 => "key e not found" 

3.0.1 :074 > h.delete_if {|k, v| v>3 }
 => {:a=>1, :b=>2, :c==>3} 
3.0.1 :075 > h
 => {:a=>1, :b=>2, :c==>3}

.................................................update value of some key.....

3.0.1 :037 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :038 > h[:d]=10
 => 10 
3.0.1 :039 > h
 => {:a=>1, :b=>2, :c=>3, :d=>10} 
.................................................using key as an array in hash.............

3.0.1 :041 > a1=[:a,:b]
 => [:a, :b] 
3.0.1 :042 > a2=[:c,:d]
 => [:c, :d] 

3.0.1 :043 > h={a1=>1,a2=>2}
 => {[:a, :b]=>1, [:c, :d]=>2} 

3.0.1 :044 > h.include?(a1)
 => true 
3.0.1 :045 > h[a1]
 => 1 
3.0.1 :046 > h[a2]
 => 2 
.................................................updating key is going to chnage the hash value

3.0.1 :049 > a1.hash
 => -3904225525138141559 
3.0.1 :050 > a1
 => [:a, :b] 
3.0.1 :052 > a1[0]=:e
 => :e 
3.0.1 :055 > a1.hash
 => -908128488615875714 
3.0.1 :056 > 
3.0.1 :054 > h
 => {[:e, :b]=>1, [:c, :d]=>2} 
.................................................. updating a1[0],damaged the hash index..........
3.0.1 :056 > h.include?(a1)
 => false 

3.0.1 :060 > h[a1]
 => nil 

....................................................to fix above use rehash method, index using below..............
3.0.1 :061 > h.rehash
 => {[:e, :b]=>1, [:c, :d]=>2} 
3.0.1 :062 > h.include?(a1)
 => true 
3.0.1 :063 > h[a1]
 => 1 
3.0.1 :064 > 
.............................................  ... set default value of hash.....if not present..................

3.0.1 :009 > count={a:1}
 => {:a=>1} 
3.0.1 :010 > count.default
 => nil 
3.0.1 :011 > count[:a]
 => 1 
3.0.1 :012 > count[:b]
 => nil 
3.0.1 :013 > count.default=0
 => 0 
3.0.1 :014 > count[:b]
 => 0 

3.0.1 :016 > count.values_at(:a,:b,:c)                 # h.values_at(:key,....)
 => [1, 0, 0] 
3.0.1 :017 > 

....................................................

3.0.1 :038 > h=Hash[[:a,1],[:b,2]]
 => {[:a, 1]=>[:b, 2]} 

3.0.1 :039 > h
 => {[:a, 1]=>[:b, 2]} 

3.0.1 :040 > h=Hash[ [ [:a, 1], [:b, 2] ] ]              #Hash[ [ [:key,val],[:k,v] ] ]
 => {:a=>1, :b=>2} 
3.0.1 :041 > 

3.0.1 :041 > h=Hash[:a, 1, :b, 2]                        #Hash[:k,v]
 => {:a=>1, :b=>2} 
 
.................................................................................
                                                        # check proper subset and subset to eachother....
3.0.1 :042 > h
 => {:a=>1, :b=>2} 

3.0.1 :043 > h2={a:1,b:2,c:3}
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :045 > h<h2                     # check proper subset h<h2
 => true 
3.0.1 :046 > h2<h
 => false 
3.0.1 :047 > h<h
 => false 
3.0.1 :048 > h<=h2                    #check subset h<=h2
 => true 
3.0.1 :049 > h2<=h
 => false 
3.0.1 :050 > h<=h
 => true 
3.0.1 :051 > 

...................................................hash.any?([:k, v]) if both match then return true................................

3.0.1 :060 > h.any?([:b,1])
 => false 
3.0.1 :061 > h.any?([:b,2])
 => true 
3.0.1 :062 > h.any? {|key, value| value <3}           # h.any? {|k, v| condition} match then return true...
 => true 
3.0.1 :063 > h.any? {|key, value| value >4}
 => false 
3.0.1 :064 > 
..............................................................# h.assoc() return an array with [k,v]...................

3.0.1 :064 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :065 > h.assoc(:a)
 => [:a, 1] 
3.0.1 :066 > 
.............................................................# h.compact return copy of hash after removing all nil val............
3.0.1 :071 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>nil, :f=>nil} 

3.0.1 :072 > h1=h.compact
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :073 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>nil, :f=>nil} 

3.0.1 :074 > h1
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :076 > h.compact!
 => {:a=>1, :b=>2, :c=>3, :d=>4}                         # return self

..............................................................# hash.fetch(:k) function .....................................

3.0.1 :010 > h
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :011 > h.fetch
3.0.1 :011 > h.fetch(:a)
 => 1 
3.0.1 :012 > h.fetch(:d)
(irb):12:in `fetch': key not found: :d (KeyError)

3.0.1 :013 > h.fetch(:d){4}                              # to ignore the above keyerror do this.....
 => 4 
3.0.1 :014 > h
 => {:a=>1, :b=>2, :c=>3} 

3.0.1 :015 > h.fetch(:d) do |k|
3.0.1 :016 >   puts "could not found #{k}"
3.0.1 :017 > end
could not found d
 => nil 
.............................................................# h.dig(:k,:k1,...)...........................

3.0.1 :021 > my_h={a: {b: {c: 1}}}                         
 => {:a=>{:b=>{:c=>1}}} 
3.0.1 :022 > my_h[:a]
 => {:b=>{:c=>1}} 
3.0.1 :023 > my_h[:b]
 => nil 
3.0.1 :024 > my_h[:c]
 => nil 
3.0.1 :025 > my_h[:a,:b,:c]
(irb):25:in `[]': wrong number of arguments (given 3, expected 1) keyerror...


3.0.1 :026 > my_h.dig(:a)                             #h.dig function useful for nested hash.....
 => {:b=>{:c=>1}} 

3.0.1 :027 > my_h.dig(:b)
 => nil 

3.0.1 :028 > my_h.dig(:c)
 => nil 
3.0.1 :029 > my_h.dig(:a,:b,:c)
 => 1 

....................................................................................................................
                                                          # iterate through hash using each..

3.0.1 :030 > h                             
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :031 > h.each do |k, v|                         #h.each
3.0.1 :032 >   puts "#{k} = #{v}"
3.0.1 :033 > end
a = 1
b = 2
c = 3
 => {:a=>1, :b=>2, :c=>3} 
.......................................
3.0.1 :037 > h.each_key do |k|                     # h.each_key
3.0.1 :038 >   puts "#{k}"
3.0.1 :039 > end
a
b
c
 => {:a=>1, :b=>2, :c=>3}
..........................................
3.0.1 :043 > h.each_key do |k|
3.0.1 :044 >   puts h[k]
3.0.1 :045 > end
1
2
3
 => {:a=>1, :b=>2, :c=>3} 
...............................................
3.0.1 :049 > h.each_value do |v|                   # h.each_value 
3.0.1 :050 >   puts v
3.0.1 :051 > end
1
2
3
 => {:a=>1, :b=>2, :c=>3} 
.................................................................................

3.0.1 :054 > h.each_with_index do |(k, v), i |                     # h.each_with_index
3.0.1 :055 >   puts "index=#{i} | key=#{k}  | value=#{v}"
3.0.1 :056 > end
index=0 | key=a  | value=1
index=1 | key=b  | value=2
index=2 | key=c  | value=3
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :057 > 
...................................................................................

3.0.1 :052 > h.keys
 => [:a, :b, :c] 
3.0.1 :053 > h.values
 => [1, 2, 3] 

3.0.1 :057 > h.to_a
 => [[:a, 1], [:b, 2], [:c, 3]] 
...............................................................  .......# h.select {}  ,.........................

3.0.1 :130 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :131 > 
3.0.1 :132 > h2=h.select{|k,v| v<4}
 => {:a=>1, :b=>2, :c=>3}
3.0.1 :133 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :134 > h2
 => {:a=>1, :b=>2, :c=>3} 
,...................................................................# h.flatten,h.flatten(n).............................

3.0.1 :139 > my_h={foo: 0, bar: [:bat, [:baz, [:bat, ]]]}

3.0.1 :140 > my_h.flatten
 => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]] 
3.0.1 :141 > my_h
 => {:foo=>0, :bar=>[:bat, [:baz, [:bat]]]} 

3.0.1 :142 > my_h.flatten(1)
 => [:foo, 0, :bar, [:bat, [:baz, [:bat]]]] 

3.0.1 :143 > my_h.flatten(2)
 => [:foo, 0, :bar, :bat, [:baz, [:bat]]] 

3.0.1 :144 > my_h.flatten(3)
 => [:foo, 0, :bar, :bat, :baz, [:bat]] 

3.0.1 :145 > my_h.flatten(4)
 => [:foo, 0, :bar, :bat, :baz, :bat] 

3.0.1 :146 > my_h.flatten(5)
 => [:foo, 0, :bar, :bat, :baz, :bat] 
...................................................................................................................................

3.0.1 :157 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :158 > my_h
 => {:foo=>0, :bar=>[:bat, [:baz, [:bat]]]} 
3.0.1 :159 > my_h.replace(h)                               # h.replace(k: v,K1:v1, ....)
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :160 > my_h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :161 > my_h.inspect                                 # h.inspect function return string as (h.to_s)........ 
 => "{:a=>1, :b=>2, :c=>3, :d=>4}" 
3.0.1 :162 > s=my_h.inspect
 => "{:a=>1, :b=>2, :c=>3, :d=>4}" 

.......................................................................
                                                          #h.invert
3.0.1 :168 > my_h                              
 => {:a=>1, :b=>2, :c=>3, :d=>4}  

3.0.1 :171 > my=my_h.invert                              # return new hash with key value inverted means k=>v and v=>k.......
 => {1=>:a, 2=>:b, 3=>:c, 4=>:d} 
3.0.1 :172 > my
 => {1=>:a, 2=>:b, 3=>:c, 4=>:d} 
3.0.1 :173 > my[1]
 => :a 
3.0.1 :174 > my[2]
 => :b
..........................................................................................................................................
                                                        # e=h.keep_if....... return enumerator
3.0.1 :178 > my_h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :181 > e=my_h.keep_if
 => #<Enumerator: ...> 

3.0.1 :183 > e
 => #<Enumerator: ...> 

3.0.1 :185 > e.each {|k, v| k.start_with?('b')}
 => {:b=>2} 

...................................................
                                                                
3.0.1 :177 > my_h={:a=>1, :b=>2, :c=>3, :d=>4}            # h.keep_if {|k,v| condition}.....return self..............           
 => {:a=>1, :b=>2, :c=>3, :d=>4}  

3.0.1 :175 > my_h.keep_if {|k, v| k.start_with?('b')}
 => {:b=>2} 

3.0.1 :176 > my_h
 => {:b=>2} 
...............................................................

3.0.1 :187 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :188 > h.length
 => 4 
3.0.1 :189 > h.size
 => 4 
3.0.1 :190 > h.has_key?(:a)
 => true 
3.0.1 :191 > h.has_key?(:b)
 => true 
3.0.1 :192 > h.key?(:c)
 => true 
3.0.1 :193 > 
...............................................................# h.merge(h1,h2......) 
                                                              # merge new key value and overwrite existing key....................

3.0.1 :193 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :196 > my={e:5}
 => {:e=>5} 
3.0.1 :198 > h.merge(my)
 => {:a=>1, :b=>2, :c=>3, :d=>4, :e=>5} 

3.0.1 :200 > my_h={b:10,c:20}
 => {:b=>10, :c=>20} 

3.0.1 :201 > h.merge(my_h)
 => {:a=>1, :b=>10, :c=>20, :d=>4} 
3.0.1 :202 > 
...........................................
3.0.1 :207 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :208 > my
 => {:e=>5} 
3.0.1 :209 > my_h
 => {:b=>10, :c=>20} 
3.0.1 :210 > hash=h.merge(my,my_h)
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 
3.0.1 :211 > hash
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 
3.0.1 :212 > 
................................................# h.merge(){|k, ov,nv| condition} ............... 

3.0.1 :212 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :213 > my
 => {:e=>5} 
3.0.1 :214 > my_h
 => {:b=>10, :c=>20} 
3.0.1 :215 > new_hash=h.merge(my,my_h){|k, o_v, n_v| o_v+n_v}
 => {:a=>1, :b=>12, :c=>23, :d=>4, :e=>5} 
3.0.1 :216 > 

..........................................................# h.assoc(:k) and h.rassoc(v)  ...........................

3.0.1 :219 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :220 > h.assoc(2)
 => nil 
3.0.1 :221 > h.assoc(:b)
 => [:b, 2] 
3.0.1 :222 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :223 > h.rassoc(:b)
 => nil 
3.0.1 :224 > h.rassoc(2)
 => [:b, 2] 
3.0.1 :225 > 

...............................................................h1=h.reject{|| cindition} ............................

3.0.1 :225 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :227 > h1=h.reject {|k,v| k.start_with?('d')}
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :228 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :229 > h1
 => {:a=>1, :b=>2, :c=>3} 
3.0.1 :230 > 
...............................................................h.slice(:k1,:k2...) ..................................

3.0.1 :231 > hash
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 
3.0.1 :233 > my=hash.slice(:a,:b)
 => {:a=>1, :b=>10} 
3.0.1 :234 > hash
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 

3.0.1 :235 > my=hash.slice(:a,:b,:f)                   #ignore the which is not present...
 => {:a=>1, :b=>10} 
3.0.1 :236 > 
...................................................................................................................
                                                     
                                                        # alias# .to_a, # to_h, # .to_h{}
3.0.1 :240 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :241 > h1=h.to_h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 

3.0.1 :242 > h2=h.to_h{|k,v| [v,k]}                      # interchange key,value as invert function.....
 => {1=>:a, 2=>:b, 3=>:c, 4=>:d} 

3.0.1 :243 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :244 > h1
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :245 > h2
 => {1=>:a, 2=>:b, 3=>:c, 4=>:d} 
3.0.1 :246 > 
,............................................................................................................................
                                                             # h.to_proc
3.0.1 :247 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :248 > proc=h.to_proc
 => #<Proc:0x000055ba90d454e0 (lambda)> 
3.0.1 :249 > proc.class
 => Proc 
3.0.1 :250 > proc.call(:a)
 => 1 
3.0.1 :251 > proc.call(:d)
 => 4 
3.0.1 :252 > proc.call(:b)
 => 2 
3.0.1 :253 > proc.call(:f)
 => nil 
3.0.1 :254 > 
...................................................................

3.0.1 :258 > hash.transform_keys {|k| k.to_s}
 => {"a"=>1, "b"=>10, "c"=>20, "d"=>4, "e"=>5} 

3.0.1 :259 > hash
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 

3.0.1 :260 > hash.transform_keys(a: :b, b: :a)
 => {:b=>1, :a=>10, :c=>20, :d=>4, :e=>5} 

3.0.1 :262 > hash
 => {:a=>1, :b=>10, :c=>20, :d=>4, :e=>5} 

3.0.1 :263 > hash.transform_keys(a: :hello,&:to_s)
 => {:hello=>1, "b"=>10, "c"=>20, "d"=>4, "e"=>5} 
 
3.0.1 :271 > h
 => {:a=>1, :b=>2, :c=>3, :d=>4} 
3.0.1 :267 > h1=h.transform_keys{|k| :bat}
 => {:bat=>4} 


